# JSDAY06

# 목차

- 브라우저의 렌더링 과정에 대해 설명해보세요 🔥
- 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥
- 이벤트 위임(delegation)에 대해서 알고있나요? 🔥
- XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요? 🔥
- HTTP 상태 코드를 아는대로 말해주세요 🔥

---

## 브라우저의 렌더링 과정에 대해 설명해보세요

가장 처음 주소창에 주소를 치면, 브라우저가 URL을 해독해서 조회할 웹 서버와 파일명, 포트번호를 판단하고 실제 HTTP 메시지 포멧에 맞게 GET 리퀘스트 메세지를 작성할 준비를 합니다.  
URL에서 해석한 정보를 바탕으로 해당 자원을 취할 수 있고 HTTP 메세지 포맷에 맞는 상태라인, 헤더, 바디를 가지고 GET 리퀘스트 메세지를 작성합니다.

댜음으로 브라우저가 도메인 주소와 IP 주소를 대응시키기 위한 서버인 DNS 요청을 OS에게 의뢰하고 실행합니다.  
엑세스 대상의 웹 서버가 DNS에 등록되어 있으면 IP 주소를 포함한 응답이 오고, 응답을 해석하여 IP 주소를 추출하여 메모리에 저장한 후 브라우저의 프로세스가 접근할 수 있게됩니다.  
브라우저는 직접 네트워크 요청을 할 수 없기 때문에 DNS 요청을 포함한 모든 네트워크 요청은 OS에게 의뢰해서 진행합니다.  
서버 어플리케이션이 http 요청 메시지를 받으면 요청 URI를 실제 서버의 파일 시스템에서 URL로 바꿔 해당되는 html을 찾아 바디에 넣은 후 리스폰스 헤더와 함께 응답 메세지를 작성합니다.  
이 응답 메세지를 받은 클라이언트의 브라우저는 HTTP의 content-type 헤더를 보고 응답 데이터가 html임을 알아냅니다. 이를 바탕으로 브라우저가 화면 표시 동작을 실행합니다.

이 화면 표시는 브라우저 프로세스의 렌더러 스레드가 담당하게 됩니다. 브라우저는 HTML을 파싱하여 Critical Rendering Path를 거치게 됩니다.  
가장 먼저 렌더링 엔진은 HTML에 수신된 bytes 형태의 HTML 문서를 문자열로 변환한 후, `<html>, <body>`같이 문법적 의미를 갖는 코드의 최소 단위 문자열인 토큰으로 분해합니다.  
각 토큰을 객체로 변환 한 후에 노드를 생성하고, HTML에 작성된 마크업을 바탕으로 모든 노드들을 트리 자료구조로 구성한 DOM 트리를 생성합니다.

브라우저는 DOM을 생성하는 동안 외부 CSS를 참조하는 `<link>`태그를 만나면 브라우저에 리소스를 요청합니다.  
CSS도 HTML과 마찬가지로 일련의 처리를 통해 토큰과 노드로 변환되고 CSSOM 트리구조를 생성합니다.

이후 렌더링 엔진에 의헤 DOM 트리와 CSSOM 트리가 완성된다면 이를 바탕으로 렌더 트리를 생성합니다.  
렌더 트리가 생성되고 기기의 뷰포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산하는 레이아웃을 생성합니다. 이 과정에서 모든 상대적인 측정값은 화면에서 절대적인 픽셀로 변환됩니다.  
다음으로 렌더 트리의 각 노드를 화면의 실제 픽셀로 나타내는 과정을 페인팅 과정을 진행하고, 페인팅 과정 후 브라우저 화면에 UI가 나타나며 렌더링 과정은 모두 종료됩니다.

만약 자바스크립트 코드를 통해 DOM이나 CSSOM이 변경된다면 이때 변경된 트리들은 다시 렌더 트리로 결합됩니다.  
변경된 렌더 트리를 바탕으로 다시 리플로우, 리페인팅 과정을 거쳐 브라우저 화면에 렌더링 됩니다.

## 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요?

자바스크립트는 파서를 차단하는 리소스입니다. 브라우저는 문서를 파싱하는 과정에서 자바스크립트를 만다면 진행하던 파싱을 중지하고 자바스크립트 엔진에게 권한을 넘겨 자바스크립트를 파싱하고 실행합니다.  
이때 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 로우 레벨 언어로 변환하고 실행합니다.  
자바스크립트가 실행되는 동안 문서의 파싱은 중단됩니다. 이후 자바스크립트 파싱과 실행이 종료되면 다시 렌더링 엔진으로 제어권을 넘겨 HTML 파싱이 중단된 시점부터 다시 DOM 생성을 진행합니다.
따라서 보통 자바스크립트를 `<body>`태그가 닫히기 전에 사용되도록 하는 것이 좋습니다.

보통은 이렇지만 `<script>`태그에 defer 속성을 준다면 문서 파싱은 중단되지 않고, 문서 파싱이 완료된 이후에 자바스크립트가 실행되게끔 할 수도 있습니다.  
또한 HTML에서 스크립트를 비동기 async로 처리 할 수도 있습니다. 이를 통해 자바스크립트가 별도의 맥락에 의해 파싱되도록 처리할 수 있습니다.

## 이벤트 위임(delegation)에 대해서 알고있나요?

이벤트 위임이란 하위 요소마다 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식을 말합니다.  
사용자의 액션에 의해 이벤트 발생 시 이벤트는 document 레벨까지 버블링 되어 올라갑니다. 이 때문에 자식 엘리먼트에서 발생하는 이벤트를 부모 엘리먼트에서도 감지할 수 있습니다.  
이를 이용한 방법이 바로 이벤트 위임입니다. 특정 엘리먼트에 이벤트를 모두 등록하지 않고 하나의 부모에 등록하여 부모에게 이벤트를 위임하게 할 수 있습니다.

이벤트 위임의 이점은 여러가지가 있습니다.  
첫 번째로 상위 엘리먼트에서만 이벤트 리스너를 관리하기 때문에 하위 엘레먼트는 자유롭게 추가 삭제 할 수 있다는 것.  
두 번째로 동일한 이벤트에 대해 한 곳에서 관리하기 때문에 각각의 엘리먼트를 여러곳에 등록하여 관리하는 것 보다 관리가 수월하다는 것  
마지막으로 동적으로 추가되는 이벤트가 없어지기 때문에 메모리 사용량이 줄어든다는 장점이 있습니다.

## XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요? 

XMLHttpRequest와 fetch 모두 비동기적 자바스크립트 통신을 하기 위한 ajax api 입니다.

XMLHttpRequest api는 document.addEventListener 처럼 전통적인 이벤트 기반으로 동작합니다.
초기 브라우저에서 ajax를 위한 비동기 통신을 위해 많이 사용되었지만 가독성이 좋지 않고 브라우저별로 인터페이스가 다르게 동작 할 수 있다는 단점이 존재합니다.  
또한 현재 비동기 처리 프로그래밍 방식으로 많이 사용되는 promise 기반이 아니므로 요즘엔 자주 기용되지 않고 있습니다.

fetch api는 ES6부터 들어온 자바스크립트 내장 메서드입니다. 내장 메서드이므로 별도의 import 없이 사용할 수 있습니다.  
fetch는 반환값으로 Promise를 가집니다. 따라서 .then, catch 같은 체이닝으로 작성할 수 있어서 가독성 및 사용법이 간단하여 자주 사용되고 있습니다

## HTTP 상태 코드를 아는대로 말해주세요

우선 HTTP란 HyperText Protocol의 약자이며 하이퍼텍스트를 빠르게 교확하기 위한 프로토콜의 일종으로, 서버와 클라이언트의 사이에서 어떻게 메세지를 교환할지 정해놓은 규칙입니다.  
요청과 응답으로 구성되어있으며, 클라이언트가 요청을 하면 서버가 응답 코드와 내용을 전송하며 응답하고 클라이언트와의 연결을 종료합니다.  
HTTP 상태 코드는 클라이언트가 보낸 HTTP 요청에 대한 서버의 응답 코드로, 상태 코드에 따라 요청의 성공/실패 여부를 판단합니다.

HTTP 상태 코드는 3자리 숫자로 이루어져 있으며, 첫 번째 자리는 1에서 5까지 제공됩니다.  
여기서 첫째 자리가 4와 5인 경우는 에러 상황으로 볼 수 있습니다.

자세하게 설명 해보면,  
첫째 자리가 1인 경우는 요청을 받았으며, 작업을 진행 중이라는 의미입니다.  
첫째 자리가 2인 경우는 클라이언트가 요청한 동작을 받아서 이해했고, 성공적으로 처리했음을 가르킵니다.  
첫째 자리가 3인 경우는 해당 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 의미입니다.  
첫째 자리가 4인 경우는 해당 요청이 올바르지 않다는 의미입니다. 해당 상태일 경우 부터는 브라우저에 직접 노출됩니다.  
첫째 자리가 5인 경우는 서버가 응답할 수 없다는 의미이며, 요청이 올바른지 여부는 알 수 없습니다.
